# My lovey algos

- ## Insertion Sort

  - ### Big O:

  - Time: O(n^2)
    The basic operation of this algorithm is comparison. This will happen n \* (n-1) number of times…concluding the algorithm to be n squared.
    -Space: O(1)
    No additional space is being created. This array is being sorted in place…keeping the space at constant O(1).
  - ### whiteboard:
    ![codeChel](https://i.ibb.co/3vjCWnb/codeChel.png)

- ## merge Sort

  How do you explain merge sort?
  Merge Sort is a divide and conquer algorithm. It works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem.

  - ### Big O:

  - Time: O(n log(n))
    This algorithm is a divide and conquer algorithm. It is a recursive algorithm.
    -Space: O(n)
  - Space: O(1)
    This algorithm requires additional space proportional to the input size.
  - ### whiteboard:
    ![27](https://i.ibb.co/K24sQnn/17.png)

- ## Quick sort

  Quicksort is an efficient in-place sorting algorithm, which usually performs about two to three times faster than merge sort and heapsort when implemented well. Quicksort is a comparison sort, meaning that it can sort items of any type for which a less-than relation is defined. In efficient implementations, it is usually not a stable sort.

  Quicksort, on average, makes O(n.log(n)) comparisons to sort n items. In the worst-case, it makes O(n2) comparisons, though this behavior is very rare.

  - ### Big O:

  - Time: O(n log(n))
    This algorithm is a divide and conquer algorithm. It is a recursive algorithm.
  - Space: O(n)
    This algorithm requires additional space proportional to the input size.
  - ### whiteboard:
    ![28](https://i.ibb.co/j9t5vRC/28.png)
